
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Monte Carlo Solver &mdash; QuTiP 5.0 Documentation</title>
      <link rel="stylesheet" href="../../static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../static/site.css" type="text/css" />
    <link rel="shortcut icon" href="../../static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../static/documentation_options.js"></script>
        <script src="../../static/doctools.js"></script>
        <script src="../../static/sphinx_highlight.js"></script>
        <script>window.MathJax = {"TeX": {"Macros": {"bra": ["\\left\\langle{#1}\\right\\rvert", 1], "ket": ["\\left\\lvert{#1}\\right\\rangle", 1], "tr": "\\operatorname{tr}"}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="next" title="Krylov Solver" href="dynamics-krylov.html" />
    <link rel="prev" title="Lindblad Master Equation Solver" href="dynamics-master.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            QuTiP: Quantum Toolbox in Python
          </a>
              <div class="version">
                5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../guide.html">Users Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../guide-overview.html">Guide Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-basics.html">Basic Operations on Quantum Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-states.html">Manipulating States and Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-tensor.html">Using Tensor Products and Partial Traces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-super.html">Superoperators, Pauli Basis and Channel Contraction</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../guide-dynamics.html">Time Evolution and Quantum System Dynamics</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="dynamics-intro.html">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-data.html">Dynamics Simulation Results</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-master.html">Lindblad Master Equation Solver</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Monte Carlo Solver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#monte-carlo-in-qutip">Monte Carlo in QuTiP</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-krylov.html">Krylov Solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-stochastic.html">Stochastic Solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-time.html">Solving Problems with Time-dependent Hamiltonians</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-class.html">Solver Class Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-bloch-redfield.html">Bloch-Redfield master equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-floquet.html">Floquet Formalism</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-nmmonte.html">Monte Carlo for Non-Markovian Dynamics</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-options.html">Setting Options for the Dynamics Solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-propagator.html">Computing propagators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../guide-heom.html">Hierarchical Equations of Motion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-steady.html">Solving for Steady-State Solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-piqs.html">Permutational Invariance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-correlation.html">Two-time correlation functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-bloch.html">Plotting on the Bloch Sphere</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-visualization.html">Visualization of quantum states and processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-saving.html">Saving QuTiP Objects and Data Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-random.html">Generating Random Quantum States &amp; Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-settings.html">Modifying Internal QuTiP Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-measurement.html">Measurement of Quantum Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-control.html">Quantum Optimal Control</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery/build/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/apidoc.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development/development.html">Development Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../biblio.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../copyright.html">Copyright and Licensing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">QuTiP: Quantum Toolbox in Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../guide.html">Users Guide</a></li>
          <li class="breadcrumb-item"><a href="../guide-dynamics.html">Time Evolution and Quantum System Dynamics</a></li>
      <li class="breadcrumb-item active">Monte Carlo Solver</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="monte-carlo-solver">
<span id="monte"></span><h1>Monte Carlo Solver<a class="headerlink" href="#monte-carlo-solver" title="Permalink to this heading"></a></h1>
<section id="introduction">
<span id="monte-intro"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<p>Where as the density matrix formalism describes the ensemble average over many
identical realizations of a quantum system, the Monte Carlo (MC), or
quantum-jump approach to wave function evolution, allows for simulating an
individual realization of the system dynamics.  Here, the environment is
continuously monitored, resulting in a series of quantum jumps in the system
wave function, conditioned on the increase in information gained about the
state of the system via the environmental measurements.  In general, this
evolution is governed by the Schrödinger equation with a <strong>non-Hermitian</strong>
effective Hamiltonian</p>
<div class="math notranslate nohighlight" id="equation-heff">
<span class="eqno">(1)<a class="headerlink" href="#equation-heff" title="Permalink to this equation"></a></span>\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]</div>
<p>where again, the <span class="math notranslate nohighlight">\(C_{n}\)</span> are collapse operators, each corresponding to a
separate irreversible process with rate <span class="math notranslate nohighlight">\(\gamma_{n}\)</span>.  Here, the strictly
negative non-Hermitian portion of Eq. <a class="reference internal" href="#equation-heff">(1)</a> gives rise to a reduction in
the norm of the wave function, that to first-order in a small time
<span class="math notranslate nohighlight">\(\delta t\)</span>, is given by
<span class="math notranslate nohighlight">\(\left&lt;\psi(t+\delta t)|\psi(t+\delta t)\right&gt;=1-\delta p\)</span> where</p>
<div class="math notranslate nohighlight" id="equation-jump">
<span class="eqno">(2)<a class="headerlink" href="#equation-jump" title="Permalink to this equation"></a></span>\[\delta p =\delta t \sum_{n}\left&lt;\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right&gt;,\]</div>
<p>and <span class="math notranslate nohighlight">\(\delta t\)</span> is such that <span class="math notranslate nohighlight">\(\delta p \ll 1\)</span>.  With a probability
of remaining in the state <span class="math notranslate nohighlight">\(\left|\psi(t+\delta t)\right&gt;\)</span> given by
<span class="math notranslate nohighlight">\(1-\delta p\)</span>, the corresponding quantum jump probability is thus Eq.
<a class="reference internal" href="#equation-jump">(2)</a>.  If the environmental measurements register a quantum jump, say via
the emission of a photon into the environment, or a change in the spin of a
quantum dot, the wave function undergoes a jump into a state defined by
projecting <span class="math notranslate nohighlight">\(\left|\psi(t)\right&gt;\)</span> using the collapse operator
<span class="math notranslate nohighlight">\(C_{n}\)</span> corresponding to the measurement</p>
<div class="math notranslate nohighlight" id="equation-project">
<span class="eqno">(3)<a class="headerlink" href="#equation-project" title="Permalink to this equation"></a></span>\[\left|\psi(t+\delta t)\right&gt;=C_{n}\left|\psi(t)\right&gt;/\left&lt;\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right&gt;^{1/2}.\]</div>
<p>If more than a single collapse operator is present in Eq. <a class="reference internal" href="#equation-heff">(1)</a>, the
probability of collapse due to the <span class="math notranslate nohighlight">\(i\mathrm{th}\)</span>-operator <span class="math notranslate nohighlight">\(C_{i}\)</span>
is given by</p>
<div class="math notranslate nohighlight" id="equation-pcn">
<span class="eqno">(4)<a class="headerlink" href="#equation-pcn" title="Permalink to this equation"></a></span>\[P_{i}(t)=\left&lt;\psi(t)|C_{i}^{+}C_{i}|\psi(t)\right&gt;/\delta p.\]</div>
<p>Evaluating the MC evolution to first-order in time is quite tedious.  Instead,
QuTiP uses the following algorithm to simulate a single realization of a quantum system.
Starting from a pure state <span class="math notranslate nohighlight">\(\left|\psi(0)\right&gt;\)</span>:</p>
<ul class="simple">
<li><p><strong>Ia:</strong> Choose a random number <span class="math notranslate nohighlight">\(r_1\)</span> between zero and one, representing
the probability that a quantum jump occurs.</p></li>
<li><p><strong>Ib:</strong> Choose a random number <span class="math notranslate nohighlight">\(r_2\)</span> between zero and one, used to
select which collapse operator was responsible for the jump.</p></li>
<li><p><strong>II:</strong> Integrate the Schrödinger equation, using the effective Hamiltonian
<a class="reference internal" href="#equation-heff">(1)</a> until a time <span class="math notranslate nohighlight">\(\tau\)</span> such that the norm of the wave function
satisfies <span class="math notranslate nohighlight">\(\left&lt;\psi(\tau)\right.\left|\psi(\tau)\right&gt; = r_1\)</span>, at
which point a jump occurs.</p></li>
<li><p><strong>III:</strong> The resultant jump projects the system at time <span class="math notranslate nohighlight">\(\tau\)</span> into one
of the renormalized states given by Eq. <a class="reference internal" href="#equation-project">(3)</a>.  The corresponding
collapse operator <span class="math notranslate nohighlight">\(C_{n}\)</span> is chosen such that <span class="math notranslate nohighlight">\(n\)</span> is the smallest
integer satisfying:</p></li>
</ul>
<div class="math notranslate nohighlight" id="equation-mc3">
<span class="eqno">(5)<a class="headerlink" href="#equation-mc3" title="Permalink to this equation"></a></span>\[\sum_{i=1}^{n} P_{n}(\tau) \ge r_2\]</div>
<p>where the individual <span class="math notranslate nohighlight">\(P_{n}\)</span> are given by Eq. <a class="reference internal" href="#equation-pcn">(4)</a>.  Note that the
left hand side of Eq. <a class="reference internal" href="#equation-mc3">(5)</a> is, by definition, normalized to unity.</p>
<ul class="simple">
<li><p><strong>IV:</strong> Using the renormalized state from step III as the new initial
condition at time <span class="math notranslate nohighlight">\(\tau\)</span>, draw a new random number, and repeat the
above procedure until the final simulation time is reached.</p></li>
</ul>
</section>
<section id="monte-carlo-in-qutip">
<span id="monte-qutip"></span><h2>Monte Carlo in QuTiP<a class="headerlink" href="#monte-carlo-in-qutip" title="Permalink to this heading"></a></h2>
<p>In QuTiP, Monte Carlo evolution is implemented with the <a class="reference internal" href="../../apidoc/functions.html#qutip.solver.mcsolve.mcsolve" title="qutip.solver.mcsolve.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcsolve</span></code></a>
function. It takes nearly the same arguments as the <a class="reference internal" href="../../apidoc/functions.html#qutip.solver.mesolve.mesolve" title="qutip.solver.mesolve.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">mesolve</span></code></a>
function for master-equation evolution, except that the initial state must be a
ket vector, as oppose to a density matrix, and there is an optional keyword
parameter <code class="docutils literal notranslate"><span class="pre">ntraj</span></code> that defines the number of stochastic trajectories to be
simulated.  By default, <code class="docutils literal notranslate"><span class="pre">ntraj=500</span></code> indicating that 500 Monte Carlo
trajectories will be performed.</p>
<p>To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP,
let’s again consider the case of a two-level atom coupled to a leaky cavity.
The only differences to the master-equation treatment is that in this case we
invoke the <a class="reference internal" href="../../apidoc/functions.html#qutip.solver.mcsolve.mcsolve" title="qutip.solver.mcsolve.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcsolve</span></code></a> function instead of <a class="reference internal" href="../../apidoc/functions.html#qutip.solver.mesolve.mesolve" title="qutip.solver.mesolve.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">mesolve</span></code></a></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">psi0</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">fock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">fock</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">a</span>  <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">qeye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">destroy</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">sm</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">destroy</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">qeye</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">H</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sm</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.25</span><span class="o">*</span><span class="p">(</span><span class="n">sm</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">+</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">],</span> <span class="n">e_ops</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">sm</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Monte Carlo time evolution&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Expectation values&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">((</span><span class="s2">&quot;cavity photon number&quot;</span><span class="p">,</span> <span class="s2">&quot;atom excitation probability&quot;</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../images/dynamics-monte-1.png" class="plot-directive" src="../../images/dynamics-monte-1.png" />
</figure>
<p>The advantage of the Monte Carlo method over the master equation approach is that
only the state vector is required to be kept in the computers memory, as opposed
to the entire density matrix. For large quantum system this becomes a significant
advantage, and the Monte Carlo solver is therefore generally recommended for such
systems. For example, simulating a Heisenberg spin-chain consisting of 10 spins
with random parameters and initial states takes almost 7 times longer using the
master equation rather than Monte Carlo approach with the default number of
trajectories running on a quad-CPU machine.  Furthermore, it takes about 7 times
the memory as well. However, for small systems, the added overhead of averaging
a large number of stochastic trajectories to obtain the open system dynamics, as
well as starting the multiprocessing functionality, outweighs the benefit of the
minor (in this case) memory saving. Master equation methods are therefore
generally more efficient when Hilbert space sizes are on the order of a couple
of hundred states or smaller.</p>
<section id="monte-carlo-solver-result">
<h3>Monte Carlo Solver Result<a class="headerlink" href="#monte-carlo-solver-result" title="Permalink to this heading"></a></h3>
<p>The Monte Carlo solver returns a <a class="reference internal" href="../../apidoc/classes.html#qutip.solver.result.McResult" title="qutip.solver.result.McResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">McResult</span></code></a> object consisting of
expectation values and/or states. The main difference with <a class="reference internal" href="../../apidoc/functions.html#qutip.solver.mesolve.mesolve" title="qutip.solver.mesolve.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">mesolve</span></code></a>’s
<a class="reference internal" href="../../apidoc/classes.html#qutip.solver.result.Result" title="qutip.solver.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> is that it optionally stores the result of each trajectory
together with their averages. When trajectories are stored, <code class="docutils literal notranslate"><span class="pre">result.runs_expect</span></code>
is a list over the expectation operators, trajectories and times in that order.
The averages are stored in <code class="docutils literal notranslate"><span class="pre">result.average_expect</span></code> and the standard derivation
of the expectation values in <code class="docutils literal notranslate"><span class="pre">result.std_expect</span></code>. When the states are returned,
<code class="docutils literal notranslate"><span class="pre">result.runs_states</span></code> will be an array of length <code class="docutils literal notranslate"><span class="pre">ntraj</span></code>. Each element
contains an array of “Qobj” type ket with the same number of elements as <code class="docutils literal notranslate"><span class="pre">times</span></code>.
<code class="docutils literal notranslate"><span class="pre">result.average_states</span></code> is a list of density matrices computed as the average
of the states at each time step. Furthermore, the output will also contain a
list of times at which the collapse occurred, and which collapse operators did
the collapse. These can be obtained in  <code class="docutils literal notranslate"><span class="pre">result.col_times</span></code> and
<code class="docutils literal notranslate"><span class="pre">result.col_which</span></code> respectively.</p>
</section>
<section id="changing-the-number-of-trajectories">
<span id="monte-ntraj"></span><h3>Changing the Number of Trajectories<a class="headerlink" href="#changing-the-number-of-trajectories" title="Permalink to this heading"></a></h3>
<p>By default, the <code class="docutils literal notranslate"><span class="pre">mcsolve</span></code> function runs 500 trajectories.
This value was chosen because it gives good accuracy, Monte Carlo errors scale
as <span class="math notranslate nohighlight">\(1/n\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of trajectories, and simultaneously
does not take an excessive amount of time to run. However, you can change the
number of trajectories to fit your needs. In order to run 1000 trajectories in
the above example, we can simply modify the call to <code class="docutils literal notranslate"><span class="pre">mcsolve</span></code> like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p>where we have added the keyword argument <code class="docutils literal notranslate"><span class="pre">ntraj=1000</span></code> at the end of the inputs.
Now, the Monte Carlo solver will calculate expectation values for both operators,
<code class="docutils literal notranslate"><span class="pre">a.dag()</span> <span class="pre">*</span> <span class="pre">a,</span> <span class="pre">sm.dag()</span> <span class="pre">*</span> <span class="pre">sm</span></code> averaging over 1000 trajectories.</p>
<p>Other than a target number of trajectories, it is possible to use a computation
time or errors bars as condition to stop computing trajectories.</p>
<p><code class="docutils literal notranslate"><span class="pre">timeout</span></code> is quite simple as <code class="docutils literal notranslate"><span class="pre">mcsolve</span></code> will stop starting the computation of
new trajectories when it is reached. Thus:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">],</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p>Will compute 60 seconds of trajectories or 1000, which ever is reached first.
The solver will finish any trajectory started when the timeout is reached. Therefore
if the computation time of a single trajectory is quite long, the overall computation
time can be much longer that the provided timeout.</p>
<p>Lastly, <code class="docutils literal notranslate"><span class="pre">mcsolve</span></code> can be instructed to stop when the statistical error of the
expectation values get under a certain value. When computing the average over
trajectories, the error on these are computed using
<a class="reference external" href="https://en.wikipedia.org/wiki/Jackknife_resampling">jackknife resampling</a>
for each expect and each time and the computation will be stopped when all these values
are under the tolerance passed to <code class="docutils literal notranslate"><span class="pre">target_tol</span></code>. Therefore:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">],</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span>
               <span class="n">ntraj</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">target_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">600</span><span class="p">)</span>
</pre></div>
</div>
<p>will stop either after all errors bars on expectation values are under <code class="docutils literal notranslate"><span class="pre">0.01</span></code>, 1000
trajectories are computed or 10 minutes have passed, whichever comes first. When a
single values is passed, it is used as the absolute value of the tolerance.
When a pair of values is passed, it is understood as an absolute and relative
tolerance pair. For even finer control, one such pair can be passed for each <code class="docutils literal notranslate"><span class="pre">e_ops</span></code>.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span>  <span class="n">target_tol</span><span class="o">=</span><span class="p">[</span>
    <span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
</div>
<p>will stop when the error bars on the expectation values of the first <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> are
under 10% of their average values.</p>
<p>If after computation of some trajectories, it is determined that more are needed, it
is possible to add trajectories to existing result by adding result together:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">run1</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">run1</span><span class="o">.</span><span class="n">num_trajectories</span><span class="p">)</span>
<span class="go">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">run2</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">run2</span><span class="o">.</span><span class="n">num_trajectories</span><span class="p">)</span>
<span class="go">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merged</span> <span class="o">=</span> <span class="n">run1</span> <span class="o">+</span> <span class="n">run2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">merged</span><span class="o">.</span><span class="n">num_trajectories</span><span class="p">)</span>
<span class="go">50</span>
</pre></div>
</div>
<p>Note that this merging operation only checks that the result are compatible –
i.e. that the <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> and <code class="docutils literal notranslate"><span class="pre">tlist</span></code> are the same. It does not check that the same initial state or
Hamiltonian where used.</p>
<p>This can be used to explore the convergence of the Monte Carlo solver.
For example, the following code block plots expectation values for 1, 10 and 100
trajectories:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="o">=</span> <span class="n">MCSolver</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">c_ops</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">])</span>
<span class="n">c_ops</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">]</span>
<span class="n">e_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">sm</span><span class="p">]</span>

<span class="n">data1</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">data10</span> <span class="o">=</span> <span class="n">data1</span> <span class="o">+</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
<span class="n">data100</span> <span class="o">=</span> <span class="n">data10</span> <span class="o">+</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>

<span class="n">expt1</span> <span class="o">=</span> <span class="n">data1</span><span class="o">.</span><span class="n">expect</span>
<span class="n">expt10</span> <span class="o">=</span> <span class="n">data10</span><span class="o">.</span><span class="n">expect</span>
<span class="n">expt100</span> <span class="o">=</span> <span class="n">data100</span><span class="o">.</span><span class="n">expect</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">expt1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ntraj=1&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">expt10</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ntraj=10&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">expt100</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ntraj=100&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Monte Carlo time evolution&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Expectation values&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../images/dynamics-monte-2.png" class="plot-directive" src="../../images/dynamics-monte-2.png" />
</figure>
</section>
<section id="using-the-improved-sampling-algorithm">
<h3>Using the Improved Sampling Algorithm<a class="headerlink" href="#using-the-improved-sampling-algorithm" title="Permalink to this heading"></a></h3>
<p>Oftentimes, quantum jumps are rare. This is especially true in the context of
simulating gates for quantum information purposes, where typical gate times are
orders of magnitude smaller than typical timescales for decoherence. In this case,
using the standard monte-carlo sampling algorithm, we often repeatedly sample the
no-jump trajectory. We can thus reduce the number of required runs by only
sampling the no-jump trajectory once. We then extract the no-jump probability
<span class="math notranslate nohighlight">\(p\)</span>, and for all future runs we only sample random numbers <span class="math notranslate nohighlight">\(r_1\)</span>
where <span class="math notranslate nohighlight">\(r_1&gt;p\)</span>, thus ensuring that a jump will occur. When it comes time to
compute expectation values, we weight the no-jump trajectory by <span class="math notranslate nohighlight">\(p\)</span> and
the jump trajectories by <span class="math notranslate nohighlight">\(1-p\)</span>. This algorithm is described in <a class="reference internal" href="../../biblio.html#abd19" id="id1"><span>[Abd19]</span></a>
and can be utilized by setting the option <code class="docutils literal notranslate"><span class="pre">&quot;improved_sampling&quot;</span></code> in the call
to <code class="docutils literal notranslate"><span class="pre">mcsolve</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">],</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;improved_sampling&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
</pre></div>
</div>
<p>where in this case the first run samples the no-jump trajectory, and the
remaining 499 trajectories are all guaranteed to include (at least) one jump.</p>
<p>The power of this algorithm is most obvious when considering systems that rarely
undergo jumps. For instance, consider the following T1 simulation of a qubit with
a lifetime of 10 microseconds (assuming time is in units of nanoseconds)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">300.0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">psi0</span> <span class="o">=</span> <span class="n">fock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">sm</span> <span class="o">=</span> <span class="n">fock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">fock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
<span class="n">omega</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="n">H0</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">sigmaz</span><span class="p">()</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">10000</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span>
    <span class="p">[</span><span class="n">H0</span><span class="p">],</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">*</span> <span class="n">sm</span><span class="p">],</span> <span class="p">[</span><span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">sm</span><span class="p">],</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">100</span>
<span class="p">)</span>
<span class="n">data_imp</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span>
    <span class="p">[</span><span class="n">H0</span><span class="p">],</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">*</span> <span class="n">sm</span><span class="p">],</span> <span class="p">[</span><span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">sm</span><span class="p">],</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;improved_sampling&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
<span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;original&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">data_imp</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;improved sampling&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">times</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\exp(-\gamma t)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Monte Carlo: improved sampling algorithm&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;time [ns]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$p_</span><span class="si">{1}</span><span class="s2">$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../images/dynamics-monte-4.png" class="plot-directive" src="../../images/dynamics-monte-4.png" />
</figure>
<p>The original sampling algorithm samples the no-jump trajectory on average 96.7%
of the time, while the improved sampling algorithm only does so once.</p>
</section>
<section id="reproducibility">
<span id="monte-seeds"></span><h3>Reproducibility<a class="headerlink" href="#reproducibility" title="Permalink to this heading"></a></h3>
<p>For reproducibility of Monte-Carlo computations it is possible to set the seed of the random
number generator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res1</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">seeds</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res2</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">seeds</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res3</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">seeds</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">res1</span><span class="p">,</span> <span class="n">res2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">res1</span><span class="p">,</span> <span class="n">res3</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">seeds</span></code> parameter can either be an integer or a numpy <code class="docutils literal notranslate"><span class="pre">SeedSequence</span></code>, which
will then be used to create seeds for each trajectory. Alternatively it may be a list of
intergers or <code class="docutils literal notranslate"><span class="pre">SeedSequence</span></code> s with one seed for each trajectories. Seeds available in
the result object can be used to redo the same evolution:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res1</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res2</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">seeds</span><span class="o">=</span><span class="n">res1</span><span class="o">.</span><span class="n">seeds</span><span class="p">,</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">res1</span><span class="p">,</span> <span class="n">res2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
<section id="running-trajectories-in-parallel">
<span id="monte-parallel"></span><h3>Running trajectories in parallel<a class="headerlink" href="#running-trajectories-in-parallel" title="Permalink to this heading"></a></h3>
<p>Monte-Carlo evolutions often need hundreds of trajectories to obtain sufficient
statistics. Since all trajectories are independent of each other, they can be computed
in parallel. The option <code class="docutils literal notranslate"><span class="pre">map</span></code> can take <code class="docutils literal notranslate"><span class="pre">&quot;serial&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;parallel&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;loky&quot;</span></code>.
Both <code class="docutils literal notranslate"><span class="pre">&quot;parallel&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;loky&quot;</span></code> compute trajectories on multiple CPUs using
respectively the <a class="reference external" href="https://docs.python.org/3/library/multiprocessing.html">multiprocessing</a>
and <a class="reference external" href="https://loky.readthedocs.io/en/stable/index.html">loky</a> python modules.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_par</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;map&quot;</span><span class="p">:</span> <span class="s2">&quot;parallel&quot;</span><span class="p">},</span> <span class="n">seeds</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_ser</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;map&quot;</span><span class="p">:</span> <span class="s2">&quot;serial&quot;</span><span class="p">},</span> <span class="n">seeds</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">res_par</span><span class="o">.</span><span class="n">average_expect</span><span class="p">,</span> <span class="n">res_ser</span><span class="o">.</span><span class="n">average_expect</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note that when running in parallel, the order in which the trajectories are added
to the result can differ. Therefore</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res_par</span><span class="o">.</span><span class="n">seeds</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
<span class="go">[SeedSequence(entropy=1,spawn_key=(1,),),</span>
<span class="go"> SeedSequence(entropy=1,spawn_key=(0,),),</span>
<span class="go"> SeedSequence(entropy=1,spawn_key=(2,),)]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res_ser</span><span class="o">.</span><span class="n">seeds</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
<span class="go">[SeedSequence(entropy=1,spawn_key=(0,),),</span>
<span class="go"> SeedSequence(entropy=1,spawn_key=(1,),),</span>
<span class="go"> SeedSequence(entropy=1,spawn_key=(2,),)]</span>
</pre></div>
</div>
</section>
<section id="photocurrent">
<h3>Photocurrent<a class="headerlink" href="#photocurrent" title="Permalink to this heading"></a></h3>
<p>The photocurrent, previously computed using the <code class="docutils literal notranslate"><span class="pre">photocurrent_sesolve</span></code> and
<code class="docutils literal notranslate"><span class="pre">photocurrent_sesolve</span></code> functions, are now included in the output of
<a class="reference internal" href="../../apidoc/functions.html#qutip.solver.mcsolve.mcsolve" title="qutip.solver.mcsolve.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcsolve</span></code></a> as <code class="docutils literal notranslate"><span class="pre">result.photocurrent</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">psi0</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">fock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">fock</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">a</span>  <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">qeye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">destroy</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">sm</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">destroy</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">qeye</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">e_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">sm</span><span class="p">]</span>
<span class="n">H</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sm</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.25</span><span class="o">*</span><span class="p">(</span><span class="n">sm</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">+</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">],</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="n">times</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">photocurrent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Monte Carlo Photocurrent&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Photon detections&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../images/dynamics-monte-5.png" class="plot-directive" src="../../images/dynamics-monte-5.png" />
</figure>
</section>
<section id="open-systems">
<h3>Open Systems<a class="headerlink" href="#open-systems" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">mcsolve</span></code> can be used to study systems which have measurement and dissipative
interactions with their environment.  This is done by passing a Liouvillian including the
dissipative interaction to the solver instead of a Hamiltonian.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">psi0</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">fock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">fock</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">a</span>  <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">qeye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">destroy</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">sm</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">destroy</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">qeye</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">H</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sm</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.25</span><span class="o">*</span><span class="p">(</span><span class="n">sm</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">+</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">liouvillian</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.01</span> <span class="o">*</span> <span class="n">sm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">])</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">],</span> <span class="n">e_ops</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">sm</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="n">times</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">photocurrent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Monte Carlo Photocurrent&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Photon detections&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../images/dynamics-monte-6.png" class="plot-directive" src="../../images/dynamics-monte-6.png" />
</figure>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="dynamics-master.html" class="btn btn-neutral float-left" title="Lindblad Master Equation Solver" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="dynamics-krylov.html" class="btn btn-neutral float-right" title="Krylov Solver" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="../../copyright.html">Copyright</a> 2011 to 2021 inclusive, QuTiP developers and contributors.
      <span class="lastupdated">Last updated on Mar 05, 2024.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>