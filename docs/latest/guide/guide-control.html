


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Quantum Optimal Control &mdash; QuTiP 4.7 Documentation</title>
  

  
  <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery-rendered-html.css" type="text/css" />
  <link rel="stylesheet" href="../static/site.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
        <script src="../static/jquery.js"></script>
        <script src="../static/underscore.js"></script>
        <script src="../static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"bra": ["\\left\\langle{#1}\\right\\rvert", 1], "ket": ["\\left\\lvert{#1}\\right\\rangle", 1], "tr": "\\operatorname{tr}"}}})</script>
    
    <script type="text/javascript" src="../static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Plotting on the Bloch Sphere" href="guide-bloch.html" />
    <link rel="prev" title="Two-time correlation functions" href="guide-correlation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> QuTiP: Quantum Toolbox in Python
          

          
          </a>

          
            
            
              <div class="version">
                4.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="guide.html">Users Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="guide-overview.html">Guide Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-basics.html">Basic Operations on Quantum Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-states.html">Manipulating States and Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-tensor.html">Using Tensor Products and Partial Traces</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-dynamics.html">Time Evolution and Quantum System Dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-heom.html">Hierarchical Equations of Motion</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-steady.html">Solving for Steady-State Solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-correlation.html">Two-time correlation functions</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Quantum Optimal Control</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#closed-quantum-systems">Closed Quantum Systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-grape-algorithm">The GRAPE algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-crab-algorithm">The CRAB Algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#optimal-quantum-control-in-qutip">Optimal Quantum Control in QuTiP</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-pulseoptim-functions">Using the pulseoptim functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="guide-bloch.html">Plotting on the Bloch Sphere</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-visualization.html">Visualization of quantum states and processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-parfor.html">Parallel computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-saving.html">Saving QuTiP Objects and Data Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-random.html">Generating Random Quantum States &amp; Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-settings.html">Modifying Internal QuTiP Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-qip.html">Quantum Information Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-measurement.html">Measurement of Quantum Objects</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../gallery/build/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../apidoc/apidoc.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/development.html">Development Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../biblio.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../copyright.html">Copyright and Licensing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QuTiP: Quantum Toolbox in Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="guide.html">Users Guide</a> &raquo;</li>
        
      <li>Quantum Optimal Control</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="quantum-optimal-control">
<span id="control"></span><h1>Quantum Optimal Control<a class="headerlink" href="#quantum-optimal-control" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In quantum control we look to prepare some specific state, effect some state-to-state transfer, or effect some transformation (or gate) on a quantum system. For a given quantum system there will always be factors that effect the dynamics that are outside of our control. As examples, the interactions between elements of the system or a magnetic field required to trap the system. However, there may be methods of affecting the dynamics in a controlled way, such as the time varying amplitude of the electric component of an interacting laser field. And so this leads to some questions; given a specific quantum system with known time-independent dynamics generator (referred to as the <em>drift</em> dynamics generators) and set of externally controllable fields for which the interaction can be described by <em>control</em> dynamics generators:</p>
<ol class="arabic simple">
<li><p>What states or transformations can we achieve (if any)?</p></li>
<li><p>What is the shape of the control pulse required to achieve this?</p></li>
</ol>
<p>These questions are addressed as <em>controllability</em> and <em>quantum optimal control</em> <a class="reference internal" href="../biblio.html#daless08" id="id1"><span>[dAless08]</span></a>. The answer to question of <em>controllability</em> is determined by the commutability of the dynamics generators and is formalised as the <em>Lie Algebra Rank Criterion</em> and is discussed in detail in <a class="reference internal" href="../biblio.html#daless08" id="id2"><span>[dAless08]</span></a>. The solutions to the second question can be determined through optimal control algorithms, or control pulse optimisation.</p>
<div class="figure align-center" id="id10">
<a class="reference internal image-reference" href="../images/quant_optim_ctrl.png"><img alt="../images/quant_optim_ctrl.png" src="../images/quant_optim_ctrl.png" style="width: 2.5in;" /></a>
<p class="caption"><span class="caption-text">Schematic showing the principle of quantum control.</span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</div>
<p>Quantum Control has many applications including NMR, <em>quantum metrology</em>, <em>control of chemical reactions</em>, and <em>quantum information processing</em>.</p>
<p>To explain the physics behind these algorithms we will first consider only finite-dimensional, closed quantum systems.</p>
</div>
<div class="section" id="closed-quantum-systems">
<h2>Closed Quantum Systems<a class="headerlink" href="#closed-quantum-systems" title="Permalink to this headline">¶</a></h2>
<p>In closed quantum systems the states can be represented by kets, and the transformations on these states are unitary operators. The dynamics generators are Hamiltonians. The combined Hamiltonian for the system is given by</p>
<div class="math notranslate nohighlight">
\[H(t) = H_0 + \sum_{j=1} u_j(t) H_j\]</div>
<p>where <span class="math notranslate nohighlight">\(H_0\)</span> is the drift Hamiltonian and the <span class="math notranslate nohighlight">\(H_j\)</span> are the control Hamiltonians. The <span class="math notranslate nohighlight">\(u_j\)</span> are time varying amplitude functions for the specific control.</p>
<p>The dynamics of the system are governed by <em>Schrödingers equation</em>.</p>
<div class="math notranslate nohighlight">
\[\tfrac{d}{dt} \ket{\psi} = -i H(t)\ket{\psi}\]</div>
<p>Note we use units where <span class="math notranslate nohighlight">\(\hbar=1\)</span> throughout. The solutions to Schrödinger’s equation are of the form:</p>
<div class="math notranslate nohighlight">
\[\ket{\psi(t)} = U(t)\ket{\psi_0}\]</div>
<p>where <span class="math notranslate nohighlight">\(\psi_0\)</span> is the state of the system at <span class="math notranslate nohighlight">\(t=0\)</span> and <span class="math notranslate nohighlight">\(U(t)\)</span> is a unitary operator on the Hilbert space containing the states. <span class="math notranslate nohighlight">\(U(t)\)</span> is a solution to the <em>Schrödinger operator equation</em></p>
<div class="math notranslate nohighlight">
\[\tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]</div>
<p>We can use optimal control algorithms to determine a set of <span class="math notranslate nohighlight">\(u_j\)</span> that will drive our system from <span class="math notranslate nohighlight">\(\ket{\psi_0}\)</span> to <span class="math notranslate nohighlight">\(\ket{\psi_1}\)</span>, this is state-to-state transfer, or drive the system from some arbitary state to a given state <span class="math notranslate nohighlight">\(\ket{\psi_1}\)</span>, which is state preparation, or effect some unitary transformation <span class="math notranslate nohighlight">\(U_{target}\)</span>, called gate synthesis. The latter of these is most important in quantum computation.</p>
</div>
<div class="section" id="the-grape-algorithm">
<h2>The GRAPE algorithm<a class="headerlink" href="#the-grape-algorithm" title="Permalink to this headline">¶</a></h2>
<p>The <strong>GR</strong>adient <strong>A</strong>scent <strong>P</strong>ulse <strong>E</strong>ngineering was first proposed in 
  <a class="reference internal" href="../biblio.html#NKhanej" id="id10"><span>[NKhanej]</span></a>. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve <span class="math notranslate nohighlight">\(T\)</span> is split into <span class="math notranslate nohighlight">\(M\)</span> timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:</p>
<div class="math notranslate nohighlight">
\[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]</div>
<p>where <span class="math notranslate nohighlight">\(k\)</span> is a timeslot index, <span class="math notranslate nohighlight">\(j\)</span> is the control index, and <span class="math notranslate nohighlight">\(N\)</span> is the number of controls. Hence <span class="math notranslate nohighlight">\(t_k\)</span> is the evolution time at the start of the timeslot, and <span class="math notranslate nohighlight">\(u_{jk}\)</span> is the amplitude of control <span class="math notranslate nohighlight">\(j\)</span> throughout timeslot <span class="math notranslate nohighlight">\(k\)</span>. The time evolution operator, or propagator, within the timeslot can then be calculated as:</p>
<div class="math notranslate nohighlight">
\[X_k:=e^{-iH(t_k)\Delta t_k}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta t_k\)</span> is the duration of the timeslot. The evolution up to (and including) any timeslot <span class="math notranslate nohighlight">\(k\)</span> (including the full evolution <span class="math notranslate nohighlight">\(k=M\)</span>) can the be calculated as</p>
<div class="math notranslate nohighlight">
\[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]</div>
<p>If the objective is state-to-state transfer then <span class="math notranslate nohighlight">\(X_0=\ket{\psi_0}\)</span> and the target <span class="math notranslate nohighlight">\(X_{targ}=\ket{\psi_1}\)</span>, for gate synthesis <span class="math notranslate nohighlight">\(X_0 = U(0) = \mathbb{1}\)</span> and the target <span class="math notranslate nohighlight">\(X_{targ}=U_{targ}\)</span>.</p>
<p>A <em>figure of merit</em> or <em>fidelity</em> is some measure of how close the evolution is to the target, based on the  control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target.</p>
<div class="math notranslate nohighlight">
\[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]</div>
<p>where <span class="math notranslate nohighlight">\(d\)</span> is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and <span class="math notranslate nohighlight">\(0 \le f \le 1\)</span>. Typically the fidelity error (or <em>infidelity</em>) is more useful, in this case defined as <span class="math notranslate nohighlight">\(\varepsilon = 1 - f_{PSU}\)</span>.  There are many other possible objectives, and hence figures of merit.</p>
<p>As there are now <span class="math notranslate nohighlight">\(N \times M\)</span> variables (the <span class="math notranslate nohighlight">\(u_{jk}\)</span>) and one
parameter to minimise <span class="math notranslate nohighlight">\(\varepsilon\)</span>, then the problem becomes a finite
multi-variable optimisation problem, for which there are many established
methods, often referred to as ‘hill-climbing’ methods. The simplest of these to
understand is that of steepest ascent (or descent). The gradient of the
fidelity with respect to all the variables is calculated (or approximated) and
a step is made in the variable space in the direction of steepest ascent (or
descent). This method is a first order gradient method. In two dimensions this
describes a method of climbing a hill by heading in the direction where the
ground rises fastest. This analogy also clearly illustrates one of the main
challenges in multi-variable optimisation, which is that all methods have a
tendency to get stuck in local maxima. It is hard to determine whether one has
found a global maximum or not - a local peak is likely not to be the highest
mountain in the region. In quantum optimal control we can typically define an
infidelity that has a lower bound of zero. We can then look to minimise the
infidelity (from here on we will only consider optimising for infidelity
minima). This means that we can terminate any pulse optimisation when the
infidelity reaches zero (to a sufficient precision). This is however only
possible for fully controllable systems; otherwise it is hard (if not
impossible) to know that the minimum possible infidelity has been achieved. In
the hill walking analogy the step size is roughly fixed to a stride, however,
in computations the step size must be chosen. Clearly there is a trade-off here
between the number of steps (or iterations) required to reach the minima and
the possibility that we might step over a minima. In practice it is difficult
to determine an efficient and effective step size.</p>
<p>The second order differentials of the infidelity with respect to the variables
can be used to approximate the local landscape to a parabola. This way a step
(or jump) can be made to where the minima would be if it were parabolic. This
typically vastly reduces the number of iterations, and removes the need to
guess a step size. The method where all the second differentials are calculated
explicitly is called the <em>Newton-Raphson</em> method. However, calculating the
second-order differentials (the Hessian matrix) can be computationally
expensive, and so there are a class of methods known as <em>quasi-Newton</em> that
approximate the Hessian based on successive iterations. The most popular of
these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno
algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is
the L-BFGS-B method in Scipy, which is a wrapper to the implementation
described in <a class="reference internal" href="../biblio.html#byrd95" id="id3"><span>[Byrd95]</span></a>. This limited memory and bounded method does not need to
store the entire Hessian, which reduces the computer memory required, and
allows bounds to be set for variable values, which considering these are field
amplitudes is often physical.</p>
<p>The pulse optimisation is typically far more efficient if the gradients can be
calculated exactly, rather than approximated. For simple fidelity measures such
as <span class="math notranslate nohighlight">\(f_{PSU}\)</span> this is possible. Firstly the propagator gradient for each
timeslot with respect to the control amplitudes is calculated. For closed
systems, with unitary dynamics, a method using the eigendecomposition is used,
which is efficient as it is also used in the propagator calculation (to
exponentiate the combined Hamiltonian). More generally (for example open
systems and symplectic dynamics) the Frechet derivative (or augmented matrix)
method is used, which is described in <a class="reference internal" href="../biblio.html#flo12" id="id4"><span>[Flo12]</span></a>. For other optimisation goals it
may not be possible to calculate analytic gradients. In these cases it is
necessary to approximate the gradients, but this can be very expensive, and can
lead to other algorithms out-performing GRAPE.</p>
</div>
<div class="section" id="the-crab-algorithm">
<h2>The CRAB Algorithm<a class="headerlink" href="#the-crab-algorithm" title="Permalink to this headline">¶</a></h2>
<p>It has been shown <a class="reference internal" href="../biblio.html#lloyd14" id="id5"><span>[Lloyd14]</span></a>, the dimension of a quantum optimal control
problem is a polynomial function of the dimension of the manifold of the
time-polynomial reachable states, when allowing for a finite control precision
and evolution time. You can think of this as the information content of the
pulse (as being the only effective input) being very limited e.g. the pulse is
compressible to a few bytes without loosing the target.</p>
<p>This is where the <strong>C</strong>hopped <strong>RA</strong>ndom <strong>B</strong>asis (CRAB) algorithm
<a class="reference internal" href="../biblio.html#doria11" id="id6"><span>[Doria11]</span></a>, <a class="reference internal" href="../biblio.html#caneva11" id="id7"><span>[Caneva11]</span></a> comes into play: Since the pulse complexity is usually
very low, it is sufficient to transform the optimal control problem to a few
parameter search by introducing a physically motivated function basis that
builds up the pulse. Compared to the number of time slices needed to accurately
simulate quantum dynamics (often equals basis dimension for Gradient based
algorithms), this number is lower by orders of magnitude, allowing CRAB to
efficiently optimize smooth pulses with realistic experimental constraints. It
is important to point out, that CRAB does not make any suggestion on the basis
function to be used. The basis must be chosen carefully considered, taking into
account a priori knowledge of the system (such as symmetries, magnitudes of
scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,
singularities, maximum excursion or rate of change,….). By doing so, this
algorithm allows for native integration of experimental constraints such as
maximum frequencies allowed, maximum amplitude, smooth ramping up and down of
the pulse and many more. Moreover initial guesses, if they are available, can
(however not have to) be included to speed up convergence.</p>
<p>As mentioned in the GRAPE paragraph, for CRAB local minima arising from
algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has
recently been introduced <a class="reference internal" href="../biblio.html#rach15" id="id8"><span>[Rach15]</span></a> that allows to escape local minima.</p>
<p>For some control objectives and/or dynamical quantum descriptions, it is either
not possible to derive the gradient for the cost functional with respect to
each time slice or it is computationally expensive to do so. The same can apply
for the necessary (reverse) propagation of the co-state. All this trouble does
not occur within CRAB as those elements are not in use here. CRAB, instead,
takes the time evolution as a black-box where the pulse goes as an input and
the cost (e.g. infidelity) value will be returned as an output. This concept,
on top, allows for direct integration in a closed loop experimental environment
where both the preliminarily open loop optimization, as well as the final
adoption, and integration to the lab (to account for modeling errors,
experimental systematic noise, …) can be done all in one, using this
algorithm.</p>
</div>
<div class="section" id="optimal-quantum-control-in-qutip">
<h2>Optimal Quantum Control in QuTiP<a class="headerlink" href="#optimal-quantum-control-in-qutip" title="Permalink to this headline">¶</a></h2>
<p>There are two separate implementations of optimal control inside QuTiP. The
first is an implementation of first order GRAPE, and is not further described
here, but there are the example notebooks. The second is referred to as Qtrl
(when a distinction needs to be made) as this was its name before it was
integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the
multi-variable optimisation, typically the L-BFGS-B method for GRAPE and
Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on
the open-source package  DYNAMO, which is a MATLAB implementation, and is
described in <a class="reference internal" href="../biblio.html#dynamo" id="id9"><span>[DYNAMO]</span></a>. It has since been restructured and extended for
flexibility and compatibility within QuTiP.</p>
<p>The rest of this section describes the Qtrl implementation and how to use it.</p>
<dl class="simple">
<dt>Object Model</dt><dd><p>The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to <a class="reference internal" href="#pulseoptim-functions"><span class="std std-ref">Using the pulseoptim functions</span></a></p>
</dd>
</dl>
<div class="figure align-center" id="id11">
<a class="reference internal image-reference" href="../images/qtrl-code_object_model.png"><img alt="../images/qtrl-code_object_model.png" src="../images/qtrl-code_object_model.png" style="width: 3.5in;" /></a>
<p class="caption"><span class="caption-text">Qtrl code object model.</span><a class="headerlink" href="#id11" title="Permalink to this image">¶</a></p>
</div>
<p>The object’s properties and methods are described in detail in the documentation, so that will not be repeated here.</p>
<dl class="simple">
<dt>OptimConfig</dt><dd><p>The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The <code class="docutils literal notranslate"><span class="pre">loadparams</span></code> module can be used read parameter values from a configuration file.</p>
</dd>
<dt>Optimizer</dt><dd><p>This acts as a wrapper to the <code class="docutils literal notranslate"><span class="pre">Scipy.optimize</span></code> functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.</p>
</dd>
<dt>Dynamics</dt><dd><p>This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.</p>
</dd>
<dt>PulseGen</dt><dd><p>There are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some kind of random pulse is used and repeated optimisations are performed until the desired infidelity is reached or the minimum infidelity found is reported.
There is a specific subclass that is used by the CRAB algorithm to generate the pulses based on the basis coefficients that are being optimised.</p>
</dd>
<dt>TerminationConditions</dt><dd><p>This is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity.</p>
</dd>
<dt>Stats</dt><dd><p>Performance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.</p>
</dd>
<dt>FidelityComputer</dt><dd><p>The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.</p>
</dd>
<dt>PropagatorComputer</dt><dd><p>This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.</p>
</dd>
<dt>TimeslotComputer</dt><dd><p>Here the time evolution is computed by calling the methods of the other computer objects.</p>
</dd>
<dt>OptimResult</dt><dd><p>The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more.</p>
</dd>
</dl>
</div>
<div class="section" id="using-the-pulseoptim-functions">
<span id="pulseoptim-functions"></span><h2>Using the pulseoptim functions<a class="headerlink" href="#using-the-pulseoptim-functions" title="Permalink to this headline">¶</a></h2>
<p>The simplest method for optimising a control pulse is to call one of the functions in the <code class="docutils literal notranslate"><span class="pre">pulseoptim</span></code> module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The <code class="docutils literal notranslate"><span class="pre">optimise_pulse</span></code> function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.</p>
<p>A semi-automated method is to use the <code class="docutils literal notranslate"><span class="pre">create_optimizer_objects</span></code> function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="guide-bloch.html" class="btn btn-neutral float-right" title="Plotting on the Bloch Sphere" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="guide-correlation.html" class="btn btn-neutral float-left" title="Two-time correlation functions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; <a href="../copyright.html">Copyright</a> 2011 to 2021 inclusive, QuTiP developers and contributors.
      <span class="lastupdated">
        Last updated on Apr 13, 2022.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>