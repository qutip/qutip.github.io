


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Measurement of Quantum Objects &mdash; QuTiP 4.7 Documentation</title>
  

  
  <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery-rendered-html.css" type="text/css" />
  <link rel="stylesheet" href="../static/site.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
        <script src="../static/jquery.js"></script>
        <script src="../static/underscore.js"></script>
        <script src="../static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"bra": ["\\left\\langle{#1}\\right\\rvert", 1], "ket": ["\\left\\lvert{#1}\\right\\rangle", 1], "tr": "\\operatorname{tr}"}}})</script>
    
    <script type="text/javascript" src="../static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Gallery" href="../gallery/build/index.html" />
    <link rel="prev" title="Pulse-level circuit simulation" href="qip/qip-processor.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> QuTiP: Quantum Toolbox in Python
          

          
          </a>

          
            
            
              <div class="version">
                4.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="guide.html">Users Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="guide-overview.html">Guide Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-basics.html">Basic Operations on Quantum Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-states.html">Manipulating States and Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-tensor.html">Using Tensor Products and Partial Traces</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-dynamics.html">Time Evolution and Quantum System Dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-heom.html">Hierarchical Equations of Motion</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-steady.html">Solving for Steady-State Solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-correlation.html">Two-time correlation functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-control.html">Quantum Optimal Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-bloch.html">Plotting on the Bloch Sphere</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-visualization.html">Visualization of quantum states and processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-parfor.html">Parallel computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-saving.html">Saving QuTiP Objects and Data Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-random.html">Generating Random Quantum States &amp; Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-settings.html">Modifying Internal QuTiP Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-qip.html">Quantum Information Processing</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Measurement of Quantum Objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performing-a-basic-measurement-observable">Performing a basic measurement (Observable)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performing-a-basic-measurement-projective">Performing a basic measurement (Projective)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#obtaining-measurement-statistics-observable">Obtaining measurement statistics(Observable)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#obtaining-measurement-statistics-projective">Obtaining measurement statistics(Projective)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../gallery/build/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../apidoc/apidoc.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/development.html">Development Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../biblio.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../copyright.html">Copyright and Licensing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QuTiP: Quantum Toolbox in Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="guide.html">Users Guide</a> &raquo;</li>
        
      <li>Measurement of Quantum Objects</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="measurement-of-quantum-objects">
<span id="measurement"></span><h1>Measurement of Quantum Objects<a class="headerlink" href="#measurement-of-quantum-objects" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New in QuTiP 4.6</p>
</div>
<div class="section" id="introduction">
<span id="measurement-intro"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Measurement is a fundamental part of the standard formulation of quantum
mechanics and is the process by which classical readings are obtained from
a quantum object. Although the interpretation of the procedure is at times
contentious, the procedure itself is mathematically straightforward and is
described in many good introductory texts.</p>
<p>Here we will show you how to perform simple measurement operations on QuTiP
objects. The same functions <a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measure" title="qutip.measurement.measure"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure</span></code></a> and
<a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measurement_statistics" title="qutip.measurement.measurement_statistics"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics</span></code></a> can be used
to handle both observable-style measurements and projective style measurements.</p>
</div>
<div class="section" id="performing-a-basic-measurement-observable">
<span id="measurement-basic"></span><h2>Performing a basic measurement (Observable)<a class="headerlink" href="#performing-a-basic-measurement-observable" title="Permalink to this headline">¶</a></h2>
<p>First we need to select some states to measure. For now, let us create an <em>up</em>
state and a <em>down</em> state:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">up</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">down</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>which represent spin-1/2 particles with their spin pointing either up or down
along the z-axis.</p>
<p>We choose what to measure (in this case) by selecting a <strong>measurement operator</strong>.
For example,
we could select <a class="reference internal" href="../apidoc/functions.html#qutip.operators.sigmaz" title="qutip.operators.sigmaz"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigmaz</span></code></a> which measures the z-component of the
spin of a spin-1/2 particle, or <a class="reference internal" href="../apidoc/functions.html#qutip.operators.sigmax" title="qutip.operators.sigmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigmax</span></code></a> which measures the
x-component:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spin_z</span> <span class="o">=</span> <span class="n">sigmaz</span><span class="p">()</span>

<span class="n">spin_x</span> <span class="o">=</span> <span class="n">sigmax</span><span class="p">()</span>
</pre></div>
</div>
<p>How do we know what these operators measure? The answer lies in the measurement
procedure itself:</p>
<ul class="simple">
<li><p>A quantum measurement transforms the state being measured by projecting it into
one of the eigenvectors of the measurement operator.</p></li>
<li><p>Which eigenvector to project onto is chosen probabilistically according to the
square of the amplitude of the state in the direction of the eigenvector.</p></li>
<li><p>The value returned by the measurement is the eigenvalue corresponding to the
chosen eigenvector.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>How to interpret this “random choosing” is the famous
“quantum measurement problem”.</p>
</div>
<p>The eigenvectors of <cite>spin_z</cite> are the states with their spin pointing either up
or down, so it measures the component of the spin along the z-axis.</p>
<p>The eigenvectors of <cite>spin_x</cite> are the states with their spin pointing either
left or right, so it measures the component of the spin along the x-axis.</p>
<p>When we measure our <cite>up</cite> and <cite>down</cite> states using the operator <cite>spin_z</cite>, we
always obtain:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qutip.measurement</span> <span class="kn">import</span> <span class="n">measure</span><span class="p">,</span> <span class="n">measurement_statistics</span>

<span class="n">measure</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">spin_z</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">up</span><span class="p">)</span>

<span class="n">measure</span><span class="p">(</span><span class="n">down</span><span class="p">,</span> <span class="n">spin_z</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">down</span><span class="p">)</span>
</pre></div>
</div>
<p>because <cite>up</cite> is the eigenvector of <cite>spin_z</cite> with eigenvalue <cite>1.0</cite> and <cite>down</cite>
is the eigenvector with eigenvalue <cite>-1.0</cite>. The minus signs are just an
arbitrary global phase – <cite>up</cite> and <cite>-up</cite> represent the same quantum state.</p>
<p>Neither eigenvector has any component in the direction of the other (they are
orthogonal), so <cite>measure(spin_z, up)</cite> returns the state <cite>up</cite> 100% percent of the
time and <cite>measure(spin_z, down)</cite> returns the state <cite>down</cite> 100% of the time.</p>
<p>Note how <a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measure" title="qutip.measurement.measure"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure</span></code></a> returns a pair of values. The
first is the measured value, i.e. an eigenvalue of the operator (e.g. <cite>1.0</cite>),
and the second is the state of the quantum system after the measurement,
i.e. an eigenvector of the operator (e.g. <cite>up</cite>).</p>
<p>Now let us consider what happens if we measure the x-component of the spin
of <cite>up</cite>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">measure</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">spin_x</span><span class="p">)</span>
</pre></div>
</div>
<p>The <cite>up</cite> state is not an eigenvector of <cite>spin_x</cite>. <cite>spin_x</cite> has two eigenvectors
which we will call <cite>left</cite> and <cite>right</cite>. The <cite>up</cite> state has equal components in
the direction of these two vectors, so measurement will select each of them
50% of the time.</p>
<p>These <cite>left</cite> and <cite>right</cite> states are:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">left</span> <span class="o">=</span> <span class="p">(</span><span class="n">up</span> <span class="o">-</span> <span class="n">down</span><span class="p">)</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>

<span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="n">up</span> <span class="o">+</span> <span class="n">down</span><span class="p">)</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
</pre></div>
</div>
<p>When <cite>left</cite> is chosen, the result of the measurement will be <cite>(-1.0, -left)</cite>.</p>
<p>When <cite>right</cite> is chosen, the result of measurement with be <cite>(1.0, right)</cite>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When <a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measure" title="qutip.measurement.measure"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure</span></code></a> is invoked with the second argument
being an observable, it acts as an alias to
<a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measure_observable" title="qutip.measurement.measure_observable"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure_observable</span></code></a>.</p>
</div>
</div>
<div class="section" id="performing-a-basic-measurement-projective">
<h2>Performing a basic measurement (Projective)<a class="headerlink" href="#performing-a-basic-measurement-projective" title="Permalink to this headline">¶</a></h2>
<p>We can also choose what to measure by specifying a <em>list of projection operators</em>. For
example, we could select the projection operators <span class="math notranslate nohighlight">\(\ket{0} \bra{0}\)</span> and
<span class="math notranslate nohighlight">\(\ket{1} \bra{1}\)</span> which measure the state in the <span class="math notranslate nohighlight">\(\ket{0}, \ket{1}\)</span>
basis. Note that these projection operators are simply the projectors determined by
the eigenstates of the <a class="reference internal" href="../apidoc/functions.html#qutip.operators.sigmaz" title="qutip.operators.sigmaz"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigmaz</span></code></a> operator.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Z0</span><span class="p">,</span> <span class="n">Z1</span> <span class="o">=</span> <span class="n">ket2dm</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">ket2dm</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>The probabilities and respective output state
are calculated for each projection operator.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">measure</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="p">[</span><span class="n">Z0</span><span class="p">,</span> <span class="n">Z1</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">up</span><span class="p">)</span>

<span class="n">measure</span><span class="p">(</span><span class="n">down</span><span class="p">,</span> <span class="p">[</span><span class="n">Z0</span><span class="p">,</span> <span class="n">Z1</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">down</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case, the projection operators are conveniently eigenstates corresponding
to subspaces of dimension <span class="math notranslate nohighlight">\(1\)</span>. However, this might not be
the case, in which case it is not possible to have unique eigenvalues for each
eigenstate. Suppose we want to measure only the first
qubit in a two-qubit system. Consider the two qubit state <span class="math notranslate nohighlight">\(\ket{0+}\)</span></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">state_0</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">state_plus</span> <span class="o">=</span> <span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>

<span class="n">state_0plus</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">state_0</span><span class="p">,</span> <span class="n">state_plus</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, suppose we want to measure only the first qubit in the computational basis.
We can do that by measuring with the projection operators
<span class="math notranslate nohighlight">\(\ket{0}\bra{0} \otimes I\)</span> and  <span class="math notranslate nohighlight">\(\ket{1}\bra{1} \otimes I\)</span>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">PZ1</span> <span class="o">=</span> <span class="p">[</span><span class="n">tensor</span><span class="p">(</span><span class="n">Z0</span><span class="p">,</span> <span class="n">identity</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span> <span class="n">tensor</span><span class="p">(</span><span class="n">Z1</span><span class="p">,</span> <span class="n">identity</span><span class="p">(</span><span class="mi">2</span><span class="p">))]</span>

<span class="n">PZ2</span> <span class="o">=</span> <span class="p">[</span><span class="n">tensor</span><span class="p">(</span><span class="n">identity</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">Z0</span><span class="p">),</span> <span class="n">tensor</span><span class="p">(</span><span class="n">identity</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">Z1</span><span class="p">)]</span>
</pre></div>
</div>
<p>Now, as in the previous example, we can measure by supplying a list of projection operators
and the state.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">measure</span><span class="p">(</span><span class="n">state_0plus</span><span class="p">,</span> <span class="n">PZ1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">state_0plus</span><span class="p">)</span>
</pre></div>
</div>
<p>The output of the measurement is the index of the measurement outcome as well
as the output state on the full Hilbert space of the input state. It is crucial to
note that we do not discard the measured qubit after measurement (as opposed to
when measuring on quantum hardware).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When <a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measure" title="qutip.measurement.measure"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure</span></code></a> is invoked with the second argument
being a list of projectors, it acts as an alias to
<a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measure_povm" title="qutip.measurement.measure_povm"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure_povm</span></code></a>.</p>
</div>
<p>The <a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measure" title="qutip.measurement.measure"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure</span></code></a> function can perform measurements on
density matrices too. You can read about these and other details at
<a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measure_povm" title="qutip.measurement.measure_povm"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure_povm</span></code></a> and <a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measure_observable" title="qutip.measurement.measure_observable"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure_observable</span></code></a>.</p>
<p>Now you know how to measure quantum states in QuTiP!</p>
</div>
<div class="section" id="obtaining-measurement-statistics-observable">
<span id="measurement-statistics"></span><h2>Obtaining measurement statistics(Observable)<a class="headerlink" href="#obtaining-measurement-statistics-observable" title="Permalink to this headline">¶</a></h2>
<p>You’ve just learned how to perform measurements in QuTiP, but you’ve also
learned that measurements are probabilistic. What if instead of just making
a single measurement, we want to determine the probability distribution of
a large number of measurements?</p>
<p>One way would be to repeat the measurement many times – and this is what
happens in many quantum experiments. In QuTiP one could simulate this using:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>  <span class="c1"># 1 and -1 are the possible outcomes</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
   <span class="n">value</span><span class="p">,</span> <span class="n">new_state</span> <span class="o">=</span> <span class="n">measure</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">spin_x</span><span class="p">)</span>
   <span class="n">results</span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Output</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{1.0: 497, -1.0: 503}
</pre></div>
</div>
<p>which measures the x-component of the spin of the <cite>up</cite> state <cite>1000</cite> times and
stores the results in a dictionary. Afterwards we expect to have seen the
result <cite>1.0</cite> (i.e. left) roughly 500 times and the result <cite>-1.0</cite> (i.e. right)
roughly 500 times, but, of course, the number of each will vary slightly
each time we run it.</p>
<p>But what if we want to know the distribution of results precisely? In a
physical system, we would have to perform the measurement many many times,
but in QuTiP we can peak at the state itself and determine the probability
distribution of the outcomes exactly in a single line:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenstates</span><span class="p">,</span> <span class="n">probabilities</span> <span class="o">=</span> <span class="n">measurement_statistics</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">spin_x</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">eigenvalues</span> 
<span class="go">array([-1., 1.])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">eigenstates</span> 
<span class="go">array([Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.70710678]</span>
<span class="go"> [-0.70710678]],</span>
<span class="go">       Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[0.70710678]</span>
<span class="go"> [0.70710678]]], dtype=object)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">probabilities</span>  
<span class="go">[0.5000000000000001, 0.4999999999999999]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measurement_statistics" title="qutip.measurement.measurement_statistics"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics</span></code></a> function then returns three values
when called with a single observable:</p>
<ul class="simple">
<li><p><cite>eigenvalues</cite> is an array of eigenvalues of the measurement operator, i.e.
a list of the possible measurement results. In our example
the value is <cite>array([-1., -1.])</cite>.</p></li>
<li><p><cite>eigenstates</cite> is an array of the eigenstates of the measurement operator, i.e.
a list of the possible final states after the measurement is complete.
Each element of the array is a <a class="reference internal" href="../apidoc/classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>.</p></li>
<li><p><cite>probabilities</cite> is a list of the probabilities of each measurement result.
In our example the value is <cite>[0.5, 0.5]</cite> since the <cite>up</cite> state has equal
probability of being measured to be in the left (<cite>-1.0</cite>) or
right (<cite>1.0</cite>) eigenstates.</p></li>
</ul>
<p>All three lists are in the same order – i.e. the first eigenvalue is
<cite>eigenvalues[0]</cite>, its corresponding eigenstate is <cite>eigenstates[0]</cite>, and
its probability is <cite>probabilities[0]</cite>, and so on.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When <a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measurement_statistics" title="qutip.measurement.measurement_statistics"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics</span></code></a>
is invoked with the second argument
being an observable, it acts as an alias to
<a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measurement_statistics_observable" title="qutip.measurement.measurement_statistics_observable"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics_observable</span></code></a>.</p>
</div>
</div>
<div class="section" id="obtaining-measurement-statistics-projective">
<h2>Obtaining measurement statistics(Projective)<a class="headerlink" href="#obtaining-measurement-statistics-projective" title="Permalink to this headline">¶</a></h2>
<p>Similarly, when we want to obtain measurement statistics for projection operators,
we can use the <cite>measurement_statistics</cite> function with the second argument being a list of projectors.
Consider again, the state <span class="math notranslate nohighlight">\(\ket{0+}\)</span>.
Suppose, now we want to obtain the measurement outcomes for the second qubit. We
must use the projectors specified earlier by <cite>PZ2</cite> which allow us to measure only
on the second qubit. Since the second qubit has the state <span class="math notranslate nohighlight">\(\ket{+}\)</span>, we get
the following result.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">collapsed_states</span><span class="p">,</span> <span class="n">probabilities</span> <span class="o">=</span> <span class="n">measurement_statistics</span><span class="p">(</span><span class="n">state_0plus</span><span class="p">,</span> <span class="n">PZ2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">collapsed_states</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Output</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket
 Qobj data =
 [[1.]
  [0.]
  [0.]
  [0.]], Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket
 Qobj data =
 [[0.]
  [1.]
  [0.]
  [0.]]]
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Output</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[0.4999999999999999, 0.4999999999999999]
</pre></div>
</div>
<p>The function <a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measurement_statistics" title="qutip.measurement.measurement_statistics"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics</span></code></a> then returns two values:</p>
<ul class="simple">
<li><p><cite>collapsed_states</cite> is an array of the possible final states after the
measurement is complete. Each element of the array is a <a class="reference internal" href="../apidoc/classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>.</p></li>
<li><p><cite>probabilities</cite> is a list of the probabilities of each measurement outcome.</p></li>
</ul>
<p>Note that the collapsed_states are exactly <span class="math notranslate nohighlight">\(\ket{00}\)</span> and <span class="math notranslate nohighlight">\(\ket{01}\)</span>
with equal probability, as expected. The two lists are in the same order.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When <a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measurement_statistics" title="qutip.measurement.measurement_statistics"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics</span></code></a>
is invoked with the second argument
being a list of projectors, it acts as an alias to
<a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measurement_statistics_povm" title="qutip.measurement.measurement_statistics_povm"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics_povm</span></code></a>.</p>
</div>
<p>The <a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measurement_statistics" title="qutip.measurement.measurement_statistics"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics</span></code></a> function can provide statistics for measurements
of density matrices too.
You can read about these and other details at
<a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measurement_statistics_observable" title="qutip.measurement.measurement_statistics_observable"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics_observable</span></code></a>
and <a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measurement_statistics_povm" title="qutip.measurement.measurement_statistics_povm"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics_povm</span></code></a>.</p>
<p>Furthermore, the <a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measure_povm" title="qutip.measurement.measure_povm"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure_povm</span></code></a>
and <a class="reference internal" href="../apidoc/functions.html#qutip.measurement.measurement_statistics_povm" title="qutip.measurement.measurement_statistics_povm"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics_povm</span></code></a> functions can
handle POVM measurements which are more general than projective measurements.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="../gallery/build/index.html" class="btn btn-neutral float-right" title="Gallery" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="qip/qip-processor.html" class="btn btn-neutral float-left" title="Pulse-level circuit simulation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; <a href="../copyright.html">Copyright</a> 2011 to 2021 inclusive, QuTiP developers and contributors.
      <span class="lastupdated">
        Last updated on Jan 17, 2024.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>