


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Solving Problems with Time-dependent Hamiltonians &mdash; QuTiP 4.7 Documentation</title>
  

  
  <link rel="stylesheet" href="../../static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../../static/gallery-rendered-html.css" type="text/css" />
  <link rel="stylesheet" href="../../static/site.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../static/documentation_options.js"></script>
        <script src="../../static/jquery.js"></script>
        <script src="../../static/underscore.js"></script>
        <script src="../../static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"bra": ["\\left\\langle{#1}\\right\\rvert", 1], "ket": ["\\left\\lvert{#1}\\right\\rangle", 1], "tr": "\\operatorname{tr}"}}})</script>
    
    <script type="text/javascript" src="../../static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="next" title="Bloch-Redfield master equation" href="dynamics-bloch-redfield.html" />
    <link rel="prev" title="Stochastic Solver" href="dynamics-stochastic.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> QuTiP: Quantum Toolbox in Python
          

          
          </a>

          
            
            
              <div class="version">
                4.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../guide.html">Users Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../guide-overview.html">Guide Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-basics.html">Basic Operations on Quantum Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-states.html">Manipulating States and Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-tensor.html">Using Tensor Products and Partial Traces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../guide-dynamics.html">Time Evolution and Quantum System Dynamics</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="dynamics-intro.html">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-data.html">Dynamics Simulation Results</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-master.html">Lindblad Master Equation Solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-monte.html">Monte Carlo Solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-krylov.html">Krylov Solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-photocurrent.html">Stochastic Solver - Photocurrent</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-stochastic.html">Stochastic Solver</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Solving Problems with Time-dependent Hamiltonians</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#methods-for-writing-time-dependent-operators">Methods for Writing Time-Dependent Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-based-time-dependence">Function Based Time Dependence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#string-format-method">String Format Method</a></li>
<li class="toctree-l4"><a class="reference internal" href="#modeling-non-analytic-and-or-experimental-time-dependent-parameters-using-interpolating-functions">Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accesing-the-state-from-solver">Accesing the state from solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reusing-time-dependent-hamiltonian-data">Reusing Time-Dependent Hamiltonian Data</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-bloch-redfield.html">Bloch-Redfield master equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-floquet.html">Floquet Formalism</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-piqs.html">Permutational Invariance</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-options.html">Setting Options for the Dynamics Solvers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../guide-heom.html">Hierarchical Equations of Motion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-steady.html">Solving for Steady-State Solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-correlation.html">Two-time correlation functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-control.html">Quantum Optimal Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-bloch.html">Plotting on the Bloch Sphere</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-visualization.html">Visualization of quantum states and processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-parfor.html">Parallel computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-saving.html">Saving QuTiP Objects and Data Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-random.html">Generating Random Quantum States &amp; Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-settings.html">Modifying Internal QuTiP Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-qip.html">Quantum Information Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-measurement.html">Measurement of Quantum Objects</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery/build/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/apidoc.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development/development.html">Development Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../biblio.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../copyright.html">Copyright and Licensing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">QuTiP: Quantum Toolbox in Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../guide.html">Users Guide</a> &raquo;</li>
        
          <li><a href="../guide-dynamics.html">Time Evolution and Quantum System Dynamics</a> &raquo;</li>
        
      <li>Solving Problems with Time-dependent Hamiltonians</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="solving-problems-with-time-dependent-hamiltonians">
<span id="time"></span><h1>Solving Problems with Time-dependent Hamiltonians<a class="headerlink" href="#solving-problems-with-time-dependent-hamiltonians" title="Permalink to this headline">¶</a></h1>
<div class="section" id="methods-for-writing-time-dependent-operators">
<h2>Methods for Writing Time-Dependent Operators<a class="headerlink" href="#methods-for-writing-time-dependent-operators" title="Permalink to this headline">¶</a></h2>
<p>In the previous examples of quantum evolution,
we assumed that the systems under consideration were described by time-independent Hamiltonians.
However, many systems have explicit time dependence in either the Hamiltonian,
or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.
The time-evolutions  solvers
<a class="reference internal" href="../../apidoc/functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve</span></code></a>, <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mcsolve</span></code></a>, <a class="reference internal" href="../../apidoc/functions.html#module-qutip.sesolve" title="qutip.sesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.sesolve</span></code></a>, <a class="reference internal" href="../../apidoc/functions.html#qutip.bloch_redfield.brmesolve" title="qutip.bloch_redfield.brmesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.bloch_redfield.brmesolve</span></code></a>
<a class="reference internal" href="../../apidoc/functions.html#qutip.stochastic.ssesolve" title="qutip.stochastic.ssesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.ssesolve</span></code></a>, <a class="reference internal" href="../../apidoc/functions.html#qutip.stochastic.photocurrent_sesolve" title="qutip.stochastic.photocurrent_sesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.photocurrent_sesolve</span></code></a>, <a class="reference internal" href="../../apidoc/functions.html#qutip.stochastic.smesolve" title="qutip.stochastic.smesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.smesolve</span></code></a>, and <a class="reference internal" href="../../apidoc/functions.html#qutip.stochastic.photocurrent_mesolve" title="qutip.stochastic.photocurrent_mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.photocurrent_mesolve</span></code></a>
are all capable of handling time-dependent Hamiltonians and collapse terms.
There are, in general, three different ways to implement time-dependent problems in QuTiP:</p>
<ol class="arabic simple">
<li><p><strong>Function based</strong>: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.</p></li>
<li><p><strong>String (Cython) based</strong>: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings.  The resulting Hamiltonian is then compiled into C code using Cython and executed.</p></li>
<li><p><strong>Array Based</strong>: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.</p></li>
<li><p><strong>Hamiltonian function (outdated)</strong>: The Hamiltonian is itself a Python function with time-dependence.  Collapse operators must be time independent using this input format.</p></li>
</ol>
<p>Given the multiple choices of input style, the first question that arrises is which option to choose?
In short, the function based method (option #1) is the most general,
allowing for essentially arbitrary coefficients expressed via user-defined functions.
However, by automatically compiling your system into C++ code,
the second option (string based) tends to be more efficient and will run faster
[This is also the only format that is supported in the <a class="reference internal" href="../../apidoc/functions.html#qutip.bloch_redfield.brmesolve" title="qutip.bloch_redfield.brmesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.bloch_redfield.brmesolve</span></code></a> solver].
Of course, for small system sizes and evolution times, the difference will be minor.
Although this method does not support all time-dependent coefficients that one can think of,
it does support essentially all problems that one would typically encounter.
Time-dependent coefficients using any of the following functions,
or combinations thereof (including constants) can be compiled directly into C++-code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;abs&#39;</span><span class="p">,</span> <span class="s1">&#39;acos&#39;</span><span class="p">,</span> <span class="s1">&#39;acosh&#39;</span><span class="p">,</span> <span class="s1">&#39;arg&#39;</span><span class="p">,</span> <span class="s1">&#39;asin&#39;</span><span class="p">,</span> <span class="s1">&#39;asinh&#39;</span><span class="p">,</span> <span class="s1">&#39;atan&#39;</span><span class="p">,</span> <span class="s1">&#39;atanh&#39;</span><span class="p">,</span> <span class="s1">&#39;conj&#39;</span><span class="p">,</span>
 <span class="s1">&#39;cos&#39;</span><span class="p">,</span> <span class="s1">&#39;cosh&#39;</span><span class="p">,</span><span class="s1">&#39;exp&#39;</span><span class="p">,</span> <span class="s1">&#39;erf&#39;</span><span class="p">,</span> <span class="s1">&#39;zerf&#39;</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;log10&#39;</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="s1">&#39;pi&#39;</span><span class="p">,</span>
 <span class="s1">&#39;proj&#39;</span><span class="p">,</span> <span class="s1">&#39;real&#39;</span><span class="p">,</span> <span class="s1">&#39;sin&#39;</span><span class="p">,</span> <span class="s1">&#39;sinh&#39;</span><span class="p">,</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="s1">&#39;tan&#39;</span><span class="p">,</span> <span class="s1">&#39;tanh&#39;</span>
</pre></div>
</div>
<p>In addition, QuTiP supports cubic spline based interpolation functions [<a class="reference internal" href="#time-interp"><span class="std std-ref">Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions</span></a>].</p>
<p>If you require mathematical functions other than those listed above,
it is possible to call any of the functions in the NumPy library using the prefix <code class="docutils literal notranslate"><span class="pre">np.</span></code>
before the function name in the string, i.e. <code class="docutils literal notranslate"><span class="pre">'np.sin(t)'</span></code> and  <code class="docutils literal notranslate"><span class="pre">scipy.special</span></code> imported as <code class="docutils literal notranslate"><span class="pre">spe</span></code>.
This includes a wide range of functionality, but comes with a small overhead created by going from C++-&gt;Python-&gt;C++.</p>
<p>Finally option #4, expressing the Hamiltonian as a Python function,
is the original method for time dependence in QuTiP 1.x.
This method is somewhat less efficient then the previously mentioned ones.
However, in contrast to the other options
this method can be used in implementing time-dependent Hamiltonians that cannot be
expressed as a function of constant operators with time-dependent coefficients.</p>
<p>A collection of examples demonstrating the simulation of time-dependent problems can be found on the <a class="reference external" href="https://qutip.org/tutorials.html">tutorials</a> web page.</p>
</div>
<div class="section" id="function-based-time-dependence">
<span id="time-function"></span><h2>Function Based Time Dependence<a class="headerlink" href="#function-based-time-dependence" title="Permalink to this headline">¶</a></h2>
<p>A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients.  To accomplish this, we need to write a Python function that returns the time-dependent coefficient.  Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function.  To do this, one needs to specify operator-function pairs in list format: <code class="docutils literal notranslate"><span class="pre">[Op,</span> <span class="pre">py_coeff]</span></code>, where <code class="docutils literal notranslate"><span class="pre">Op</span></code> is a given Hamiltonian or collapse operator and <code class="docutils literal notranslate"><span class="pre">py_coeff</span></code> is the name of the Python function representing the coefficient.  With this format, the form of the Hamiltonian for both <code class="docutils literal notranslate"><span class="pre">mesolve</span></code> and <code class="docutils literal notranslate"><span class="pre">mcsolve</span></code> is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="n">py_coeff1</span><span class="p">],</span> <span class="p">[</span><span class="n">H2</span><span class="p">,</span> <span class="n">py_coeff2</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> 
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">H0</span></code> is a time-independent Hamiltonian, while <code class="docutils literal notranslate"><span class="pre">H1</span></code> and <code class="docutils literal notranslate"><span class="pre">H2</span></code> are time-dependent. The same format can be used for collapse operators:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">C0</span><span class="p">,</span> <span class="n">py_coeff0</span><span class="p">],</span> <span class="n">C1</span><span class="p">,</span> <span class="p">[</span><span class="n">C2</span><span class="p">,</span> <span class="n">py_coeff2</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> 
</pre></div>
</div>
<p>Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter.  In addition, any or all of the collapse operators may be time-dependent.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first.</p>
</div>
<p>As an example, we will look at an example that has a time-dependent Hamiltonian of the form <span class="math notranslate nohighlight">\(H=H_{0}-f(t)H_{1}\)</span> where <span class="math notranslate nohighlight">\(f(t)\)</span> is the time-dependent driving strength given as <span class="math notranslate nohighlight">\(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\)</span>.  The following code sets up the problem</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ustate</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">excited</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ground</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># Set where to truncate Fock state for cavity</span>
<span class="n">sigma_ge</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">qeye</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">ground</span> <span class="o">*</span> <span class="n">excited</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span>  <span class="c1"># |g&gt;&lt;e|</span>
<span class="n">sigma_ue</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">qeye</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">ustate</span> <span class="o">*</span> <span class="n">excited</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span>  <span class="c1"># |u&gt;&lt;e|</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">ada</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">num</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

<span class="n">c_ops</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Build collapse operators</span>
<span class="n">kappa</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="c1"># Cavity decay rate</span>
<span class="n">c_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Atomic decay rate</span>
<span class="n">c_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">gamma</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma_ue</span><span class="p">)</span> <span class="c1"># Use Rb branching ratio of 5/9 e-&gt;u</span>
<span class="n">c_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">gamma</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma_ge</span><span class="p">)</span> <span class="c1"># 4/9 e-&gt;g</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="c1"># Define time vector</span>
<span class="n">psi0</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ustate</span><span class="p">)</span> <span class="c1"># Define initial state</span>

<span class="n">state_GG</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ground</span><span class="p">)</span> <span class="c1"># Define states onto which to project</span>
<span class="n">sigma_GG</span> <span class="o">=</span> <span class="n">state_GG</span> <span class="o">*</span> <span class="n">state_GG</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
<span class="n">state_UU</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ustate</span><span class="p">)</span>
<span class="n">sigma_UU</span> <span class="o">=</span> <span class="n">state_UU</span> <span class="o">*</span> <span class="n">state_UU</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>

<span class="n">g</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># coupling strength</span>
<span class="n">H0</span> <span class="o">=</span> <span class="o">-</span><span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma_ge</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">sigma_ge</span><span class="p">)</span>  <span class="c1"># time-independent term</span>
<span class="n">H1</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma_ue</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">+</span> <span class="n">sigma_ue</span><span class="p">)</span>  <span class="c1"># time-dependent term</span>
</pre></div>
</div>
<p>Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient <span class="math notranslate nohighlight">\(f(t)\)</span>.  In this case, one can simply do</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="mf">5.</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case, the return value depends only on time.  However, when specifying Python functions for coefficients, <strong>the function must have (t,args) as the input variables, in that order</strong>.  Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve</span></code></a>)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,[</span><span class="n">H1</span><span class="p">,</span> <span class="n">H1_coeff</span><span class="p">]]</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">ada</span><span class="p">,</span> <span class="n">sigma_UU</span><span class="p">,</span> <span class="n">sigma_GG</span><span class="p">])</span>
</pre></div>
</div>
<p>We can call the Monte Carlo solver in the exact same way (if using the default <code class="docutils literal notranslate"><span class="pre">ntraj=500</span></code>):</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="go">output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG])</span>
</pre></div>
</div>
<p>The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example.  In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">kappa</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="k">def</span> <span class="nf">col_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>  <span class="c1"># coefficient function</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">))</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># number of basis states</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span>  <span class="c1"># simple HO</span>
<span class="n">psi0</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>  <span class="c1"># initial state</span>
<span class="n">c_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="n">col_coeff</span><span class="p">]]</span>  <span class="c1"># time-dependent collapse term</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">])</span>
</pre></div>
</div>
<div class="section" id="using-the-args-variable">
<h3>Using the args variable<a class="headerlink" href="#using-the-args-variable" title="Permalink to this headline">¶</a></h3>
<p>In the previous example we hardcoded all of the variables, driving amplitude <span class="math notranslate nohighlight">\(A\)</span> and width <span class="math notranslate nohighlight">\(\sigma\)</span>, with their numerical values.  This is fine for problems that are specialized, or that we only want to run once.  However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run.  QuTiP allows you to accomplish this using the keyword <code class="docutils literal notranslate"><span class="pre">args</span></code> as an input to the solvers.  For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the <code class="docutils literal notranslate"><span class="pre">args</span></code> variable</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>or equivalently,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
      <span class="n">A</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
      <span class="n">sig</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">sig</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">args</span></code> is a Python dictionary of <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">value</span></code> pairs <code class="docutils literal notranslate"><span class="pre">args</span> <span class="pre">=</span> <span class="pre">{'A':</span> <span class="pre">a,</span> <span class="pre">'sigma':</span> <span class="pre">b}</span></code> where <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are the two parameters for the amplitude and width, respectively.  Of course, we can always hardcode the values in the dictionary as well <code class="docutils literal notranslate"><span class="pre">args</span> <span class="pre">=</span> <span class="pre">{'A':</span> <span class="pre">9,</span> <span class="pre">'sigma':</span> <span class="pre">5}</span></code>, but there is much more flexibility by using variables in <code class="docutils literal notranslate"><span class="pre">args</span></code>.  To let the solvers know that we have a set of args to pass we append the <code class="docutils literal notranslate"><span class="pre">args</span></code> to the end of the solver input:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">output</span> <span class="o">=</span> <span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
<p>or to keep things looking pretty</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>Once again, the Monte Carlo solver <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mcsolve</span></code></a> works in an identical manner.</p>
</div>
</div>
<div class="section" id="string-format-method">
<span id="time-string"></span><h2>String Format Method<a class="headerlink" href="#string-format-method" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You must have Cython installed on your computer to use this format.  See <a class="reference internal" href="../../installation.html#install"><span class="std std-ref">Installation</span></a> for instructions on installing Cython.</p>
</div>
<p>The string-based time-dependent format works in a similar manner as the previously discussed Python function method.  That being said, the underlying code does something completely different.  When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code.  The details of this meta-programming will be published in due course.  However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.</p>
<p>Like the previous method, the string-based format uses a list pair format <code class="docutils literal notranslate"><span class="pre">[Op,</span> <span class="pre">str]</span></code> where <code class="docutils literal notranslate"><span class="pre">str</span></code> is now a string representing the time-dependent coefficient.  For our first example, this string would be <code class="docutils literal notranslate"><span class="pre">'9</span> <span class="pre">*</span> <span class="pre">exp(-(t</span> <span class="pre">/</span> <span class="pre">5.)</span> <span class="pre">**</span> <span class="pre">2)'</span></code>.  The Hamiltonian in this format would take the form:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ustate</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">excited</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ground</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># Set where to truncate Fock state for cavity</span>

<span class="n">sigma_ge</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">qeye</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">ground</span> <span class="o">*</span> <span class="n">excited</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span>  <span class="c1"># |g&gt;&lt;e|</span>
<span class="n">sigma_ue</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">qeye</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">ustate</span> <span class="o">*</span> <span class="n">excited</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span>  <span class="c1"># |u&gt;&lt;e|</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">ada</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">num</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

<span class="n">c_ops</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Build collapse operators</span>
<span class="n">kappa</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="c1"># Cavity decay rate</span>
<span class="n">c_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Atomic decay rate</span>
<span class="n">c_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">gamma</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma_ue</span><span class="p">)</span> <span class="c1"># Use Rb branching ratio of 5/9 e-&gt;u</span>
<span class="n">c_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">gamma</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma_ge</span><span class="p">)</span> <span class="c1"># 4/9 e-&gt;g</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="c1"># Define time vector</span>
<span class="n">psi0</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ustate</span><span class="p">)</span> <span class="c1"># Define initial state</span>
<span class="n">state_GG</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ground</span><span class="p">)</span> <span class="c1"># Define states onto which to project</span>
<span class="n">sigma_GG</span> <span class="o">=</span> <span class="n">state_GG</span> <span class="o">*</span> <span class="n">state_GG</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
<span class="n">state_UU</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ustate</span><span class="p">)</span>
<span class="n">sigma_UU</span> <span class="o">=</span> <span class="n">state_UU</span> <span class="o">*</span> <span class="n">state_UU</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>

<span class="n">g</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># coupling strength</span>
<span class="n">H0</span> <span class="o">=</span> <span class="o">-</span><span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma_ge</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">sigma_ge</span><span class="p">)</span>  <span class="c1"># time-independent term</span>
<span class="n">H1</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma_ue</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">+</span> <span class="n">sigma_ue</span><span class="p">)</span>  <span class="c1"># time-dependent term</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="s1">&#39;9 * exp(-(t / 5) ** 2)&#39;</span><span class="p">]]</span>
</pre></div>
</div>
<p>Notice that this is a valid Hamiltonian for the string-based format as <code class="docutils literal notranslate"><span class="pre">exp</span></code> is included in the above list of suitable functions. Calling the solvers is the same as before:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">output</span> <span class="o">=</span> <span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">])</span>
</pre></div>
</div>
<p>We can also use the <code class="docutils literal notranslate"><span class="pre">args</span></code> variable in the same manner as before, however we must rewrite our string term to read: <code class="docutils literal notranslate"><span class="pre">'A</span> <span class="pre">*</span> <span class="pre">exp(-(t</span> <span class="pre">/</span> <span class="pre">sig)</span> <span class="pre">**</span> <span class="pre">2)'</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="s1">&#39;A * exp(-(t / sig) ** 2)&#39;</span><span class="p">]]</span>
<span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;sig&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Naming your <code class="docutils literal notranslate"><span class="pre">args</span></code> variables <code class="docutils literal notranslate"><span class="pre">exp</span></code>, <code class="docutils literal notranslate"><span class="pre">sin</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code> etc. will cause errors when using the string-based format.</p>
</div>
<p>Collapse operators are handled in the exact same way.</p>
</div>
<div class="section" id="modeling-non-analytic-and-or-experimental-time-dependent-parameters-using-interpolating-functions">
<span id="time-interp"></span><h2>Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions<a class="headerlink" href="#modeling-non-analytic-and-or-experimental-time-dependent-parameters-using-interpolating-functions" title="Permalink to this headline">¶</a></h2>
<p>Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points).  In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver.  QuTiP includes its own custom cubic spline interpolation class <a class="reference internal" href="../../apidoc/classes.html#qutip.interpolate.Cubic_Spline" title="qutip.interpolate.Cubic_Spline"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.interpolate.Cubic_Spline</span></code></a> to provide this functionality.  To see how this works, lets first generate some noisy data:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">9</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span><span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">noisy_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mf">0.05</span><span class="o">*</span><span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">noisy_data</span> <span class="o">=</span> <span class="n">noisy_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">noisy_data</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-default">
<img alt="../../images/dynamics-time-13.png" src="../../images/dynamics-time-13.png" />
</div>
<p>To turn these data points into a function we call the QuTiP <a class="reference internal" href="../../apidoc/classes.html#qutip.interpolate.Cubic_Spline" title="qutip.interpolate.Cubic_Spline"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.interpolate.Cubic_Spline</span></code></a> class using the first and last domain time points, <code class="docutils literal notranslate"><span class="pre">t[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">t[-1]</span></code>, respectively, as well as the entire array of data points:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="n">Cubic_Spline</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">noisy_data</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">noisy_data</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-default">
<img alt="../../images/dynamics-time-14.png" src="../../images/dynamics-time-14.png" />
</div>
<p>Note that, at present, only equally spaced real or complex data sets can be accommodated.  This cubic spline class <code class="docutils literal notranslate"><span class="pre">S</span></code> can now be pasted to any of the <code class="docutils literal notranslate"><span class="pre">mesolve</span></code>, <code class="docutils literal notranslate"><span class="pre">mcsolve</span></code>, or <code class="docutils literal notranslate"><span class="pre">sesolve</span></code> functions where one would normally input a time-dependent function or string-representation.  Taking the problem from the previous section as an example.  We would make the replacement:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="s1">&#39;9 * exp(-(t / 5) ** 2)&#39;</span><span class="p">]]</span>
</pre></div>
</div>
<p>to</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="n">S</span><span class="p">]]</span>
</pre></div>
</div>
<p>When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class.  That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format.  In the string-format, the interpolation function is compiled into c-code, and thus is quite fast.  This is the default method if no other time-dependent terms are present.</p>
</div>
<div class="section" id="accesing-the-state-from-solver">
<span id="time-dynargs"></span><h2>Accesing the state from solver<a class="headerlink" href="#accesing-the-state-from-solver" title="Permalink to this headline">¶</a></h2>
<p>New in QuTiP 4.4</p>
<p>The state of the system, the ket vector or the density matrix,
is available to time-dependent Hamiltonian and collapse operators in <code class="docutils literal notranslate"><span class="pre">args</span></code>.
Some keys of the argument dictionary are understood by the solver to be values
to be updated with the evolution of the system.
The state can be obtained in 3 forms: <code class="docutils literal notranslate"><span class="pre">Qobj</span></code>, vector (1d <code class="docutils literal notranslate"><span class="pre">np.array</span></code>), matrix (2d <code class="docutils literal notranslate"><span class="pre">np.array</span></code>),
expectation values and collapse can also be obtained.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 19%" />
<col style="width: 17%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td><p>Preparation</p></td>
<td><p>usage</p></td>
<td><p>Notes</p></td>
</tr>
<tr class="row-even"><td><p>state as Qobj</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">name+&quot;=Qobj&quot;:psi0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">psi_t=args[name]</span></code></p></td>
<td><p>The ket or density matrix as a Qobj with <code class="docutils literal notranslate"><span class="pre">psi0</span></code>’s dimensions</p></td>
</tr>
<tr class="row-odd"><td><p>state as matrix</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">name+&quot;=mat&quot;:psi0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mat_t=args[name]</span></code></p></td>
<td><p>The state as a matrix, equivalent to <code class="docutils literal notranslate"><span class="pre">state.full()</span></code></p></td>
</tr>
<tr class="row-even"><td><p>state as vector</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">name+&quot;=vec&quot;:psi0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">vec_t=args[name]</span></code></p></td>
<td><p>The state as a vector, equivalent to <code class="docutils literal notranslate"><span class="pre">state.full().ravel('F')</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>expectation value</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">name+&quot;=expect&quot;:O</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">e=args[name]</span></code></p></td>
<td><p>Expectation value of the operator <code class="docutils literal notranslate"><span class="pre">O</span></code>, either
<span class="math notranslate nohighlight">\(\left&lt;\psi(t)|O|\psi(t)\right&gt;\)</span>
or <span class="math notranslate nohighlight">\(\rm{tr}\left(O \rho(t)\right)\)</span></p></td>
</tr>
<tr class="row-even"><td><p>collpases</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">name+&quot;=collapse&quot;:[]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">col=args[name]</span></code></p></td>
<td><p>List of collapse,
each collapse is a tuple of the pair <code class="docutils literal notranslate"><span class="pre">(time,</span> <span class="pre">which)</span></code>
<code class="docutils literal notranslate"><span class="pre">which</span></code> being the indice of the collapse operator.
<code class="docutils literal notranslate"><span class="pre">mcsolve</span></code> only.</p></td>
</tr>
</tbody>
</table>
<p>Here <code class="docutils literal notranslate"><span class="pre">psi0</span></code> is the initial value used for tests before the evolution begins.
<a class="reference internal" href="../../apidoc/functions.html#qutip.bloch_redfield.brmesolve" title="qutip.bloch_redfield.brmesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.bloch_redfield.brmesolve</span></code></a> does not support these arguments.</p>
</div>
<div class="section" id="reusing-time-dependent-hamiltonian-data">
<h2>Reusing Time-Dependent Hamiltonian Data<a class="headerlink" href="#reusing-time-dependent-hamiltonian-data" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section covers a specialized topic and may be skipped if you are new to QuTiP.</p>
</div>
<p>When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation.  To turn on the the reuse features, we must pass a <a class="reference internal" href="../../apidoc/classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a> object with the <code class="docutils literal notranslate"><span class="pre">rhs_reuse</span></code> flag turned on.  Instructions on setting flags are found in <a class="reference internal" href="dynamics-options.html#options"><span class="std std-ref">Setting Options for the Dynamics Solvers</span></a>.  For example, we can do</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="s1">&#39;A * exp(-(t / sig) ** 2)&#39;</span><span class="p">]]</span>
<span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;sig&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
<span class="n">opts</span> <span class="o">=</span> <span class="n">Options</span><span class="p">(</span><span class="n">rhs_reuse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;sig&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">opts</span><span class="p">)</span>
</pre></div>
</div>
<p>The second call to <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mcsolve</span></code></a> does not reorganize the data, and in the case of the string format, does not recompile the Cython code.  For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="dynamics-bloch-redfield.html" class="btn btn-neutral float-right" title="Bloch-Redfield master equation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="dynamics-stochastic.html" class="btn btn-neutral float-left" title="Stochastic Solver" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; <a href="../../copyright.html">Copyright</a> 2011 to 2021 inclusive, QuTiP developers and contributors.
      <span class="lastupdated">
        Last updated on Jan 17, 2024.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>